# 执行引擎
## 物理算子
用于真正执行可以直接执行的执行计划，即物理执行计划
物理执行计划的来源是逻辑执行计划。

### 扫描算子
扫描算子来源于逻辑算子 ScanOperator, 可以有几种不同的实现机会：
- 表扫描 (TableScan)
- 索引扫描 (IndexScan)
- 覆盖索引扫描 (CoveredIndexScan)

### 排序算子
排序算子的实现方式有内排序和外排序的区别，其中：
- 内排序：在内存中进行数据的排序，可以使用快速排序、堆排序等算法
- 外排序：内存中放不下这么多缓存数据，需要在磁盘中进行缓存，因此涉及到外部存储，即外排序。可以使用多路归并排序算法。

在代码实现上，我们可以给他们实现成两个不同的类，也可以通过参数（字段、属性）进行判断。
代码实现在 Sort 算子中。

### 聚合算子
聚合算子是用来将某一（些）列中的数值，聚合起来的操作，具体的案例住在课件演示上有。
该聚合算子产生自 group by 子句。
其实现方式有基于哈希表的，也有先排序，然后再聚合的。
我们此时，实现的是基于哈希表的聚合算子，准确来讲，哈希表应该下盘，但是我们为了方便简单演示，就忽略了下盘(overflow)的过程了。
其是下盘的过程，比Sort的下盘过程理论上要简单点，针对hash key下盘就可以了。
我们此时实现的是：
- HashAgg

### 连接算子
连接算子是Join子句产生出来的算子，该算子用于将两个表连接到一起，故得到连接算子的名字。
在实现上，可以有 NestedLoopJoin, HashJoin等不同形式，但是NLJ是最基本的实现机制，支持最多的连接条件类别。
我们此时实现的是：
- NestedLoopJoin

